		frame_m(...) - a general-purpose frame manipulation routine.


Usage:		# include "idsp.h"
		int frame_m(FRAME * frame, char * commands, ...);


Description:	frame_m is a powerful general-purpose frame 
manipulation routine.  A frames' fields are manipulated according to 
instructions given by the commands parameter.  Each character in the 
command string represents one instruction, and will expect zero or 
one parameters.  This is a list of the available commands, and the 
parameters they expect:

c (unsigned)	Set the CONTROL word.
t (double)	Set the TIME field
j (double)	Set the JERK field.
a (double)	Set the ACCELERATION field.
v (double)	Set the VELOCITY field
x (double)	Set the POSITION field
u (unsigned)	Set the TRIGGER/UPDATE field
n (unsigned)	Set the TRIGGER ACTION field
O (unsigned, unsigned, unsigned, unsigned)
		Set the OUTPUT field
0 (--)		(The number zero.)  Clear the frame.
l (unsigned)	(Lowercase 'L'.) Allocate a frame.
d (--)		Download a frame.
- (--)		Disable UOM conversions
* (unsigned*)	Get the DSP's allocated address of this frame
e (unsigned)	Set the NEXT pointer
P (DSP*)	Set the DSP Pointer.

	frame_m(...) ignores spaces in the command string, allowing a 
bit of command-string formatting.

	If any part of the command fails, the error code generated by 
the failing operation is returned.  No further processing is 
attempted.

	The library maintains a single global FRAME variable, which 
can be used with any frame_m(...) call by passing NULL as the first 
parameter.

	Here is a command-by-command description of each operation. 
The set_conversion(...) function determines the units of measure for 
time and distance figures.  The default time unit is 1 second, and 
the default distance is counts or steps.

c (unsigned)	Set the CONTROL word.  The CONTROL word is broken 
into three fields:  the Frame control bits (bits 11-15), the Next 
priority (bits 4-7) and Frame priority (bits 0-3):
	If FCTL_RELEASE (0x8000) is turned on, the DSP will release 
the frame after it is completed.  This is turned on by default, just 
after a frame clear (see '0') is performed.
	If FCTL_INTERRUPT (0x4000) is on, then the DSP generates a PC 
interrupt when the frame begins execution.
	If FCTL_HOLD (0x2000) is on, and the axis hold bit is on, 
then the DSP will not load this frame.  Frame execution will wait 
until the axis hold bit is reset.  See below for more details.

	By default, the Next priority is 1, and the Frame priority is 
2.  These values are set after frame clear.  These fields determine 
under what exceptional conditions a frame may execute.

      t (double)	Set the TIME field.  The time is by default given in 
seconds, but set_conversion(...) can change this.  The DSP's sample 
rate determines the maximum resolution of the timer.  The default 
sample timer is 1250Hz, so the time is rounded to the nearest 
1/1250th of a second.  Time is only useful as a trigger field, 
because the DSP automatically sets the timer to 0 at the start of 
each frame.

     j (double)	The JERK field is updated as distance/time_.

     a (double)	ACCELERATION is udpated as distance/time_.

     v (double)	VELOCITY field is updated as distance/time.

     x (double)	Set the absolute POSITION field, in distance units 
(which are by default whole counts).
u (unsigned)	Set the TRIGGER/UPDATE field.  The FUPD_... bits 
determine which trajectory-calculator parameters are directly updated 
by this frame, and the FTRG_... values determine when the trigger 
action is to be taken:
       FUPD_JERK	Update the calculator's JERK value.
       FUPD_ACCEL	Update the calculator's ACCEL value.
       FUPD_VELOCITY	Update the VELOCITY figure,
       FUPD_POSITION	Update the command-position value.
       FTRG_TIME	Do the trigger action when the actual time exceeds 
			the TIME field.
       FTRG_ACCEL	Trigger when the ACCEL figure exceeds the given value.
       FTRG_VELOCITY	Trigger when the command velocity exceeds the frame's 
			VELOCITY figure.
       FTRG_POSITION	Trigger when the command position exceeds the frame's 
			POSITION field.

       n (unsigned)	The TRIGGER ACTION field has two parts, the 'Negative 
bit' and the action to perform:
     TRIGGER_NEGATIVE(0x8000)	must be turned on when an actual 
				value must be less than the trigger value to
				trigger.
     NEW_FRAME, ABORT_EVENT, STOP_EVENT, E_STOP_EVENT
	Any one of the above actions will be performed after a 
trigger condition is reached.  This field is set to NEW_FRAME by 
default.

	O (unsigned offset, unsigned addr, unsigned ormask, unsigned andmask) 
(the letter 'oh'.)  Each frame has the ability to turn on and off any 
of the bits of any word in memory.  This is achieved through a 
three-word structure dynamically located with a frame.  The structure 
consists of a word for the address to modify (addr), a word showing 
which bits to turn on (ormask), and which bits to turn off (andmask). 
Setting a port to a specific value can be easily done by passing the 
desired value as both the and and or masks.  Since the three-word 
structure can be any place within the frame, several identifiers are 
defined in IDSP.H showing the structure location:
	OUTPUT_JERK tells the DSP to look in the jerk field for these 
three words, OUTPUT_ACCEL, OUTPUT_VELOCITY, and OUTPUT_POSITION are 
also available.
	If FUPD_OUTPUT is specified in the Trigger/Update mask, then 
the controller will perform the specified I/O modification.  Remember 
that a field used for some other purpose should not be reallocated 
for an output operation--this would produce some unanticipated 
effects!

	0 (--)		(The number zero.)  Clear the frame.  All fields are 
first set to zero.  Then the CONTROL field is set to FCTL_RELEASE, 
and the TRIGGER ACTION field is set to NEW_FRAME.

	l (unsigned)	Allocate a frame.  The axis number is given as the 
associated parameter.  A frame must be allocated before it can be 
used.  Be sure, however, not to '0' a frame after it's been allocated.

	d (--)		Download a frame.  A frame must first be allocated, 
then its fields updated, then downloaded to the board.  The DSP can 
only use a frame after its been downloaded.

	- (--)		Disable UOM conversions.  During the rest of the 
frame_m(...) call, all times are in terms of samples, and distances 
in terms of fractions (1/65536 of a count for position, or 1/2__ for 
velocity, acceleration, or jerk rates).

	* (unsigned*)	Get the DSP's allocated address of this frame.  After 
a frame is allocated, use this command to get it's external data 
memory address.  This is useful in setting the NEXT field of future 
frames, to set up circular frame lists.

	e (unsigned)	Set the NEXT pointer.  Be sure to set this to a valid 
frame address.

	P (DSP*)	Set the DSP Pointer.  This changes the DSP board used 
in the rest of the call.  This is only necessary if there are several 
DSP boards installed in one computer.  The default DSP pointer is 
restored before exiting frame_m(...).

Examples:
Here are a few examples.

1)  A simple controlled velocity move.

int positive_vel(int axis, double vel, double accel)
{	int e;
	FRAME frame;

	e = frame_m(&frame, "0l av u d",
			axis, accel, vel, FUPD_ACCEL | FTRG_VELOCITY);
	if (!e)
		e = frame_m(&frame, "0l av u d",
			axis, (double) 0.0, vel, FUPD_ACCEL|FUPD_VELOCITY);
	if (!e)
		e = pcdsp_set_pc_event(&dsp, axis, NEW_FRAME);
	return e;
}

This frame downloads two frames--an acceleration frame and a constant 
velocity slewing frame.  The call to pcdsp_set_pc_event simply begins 
execution of the next frame--causing the motion to begin.

The first frame updates the acceleration, and uses the final velocity 
to trigger the next frame.  Note that since the DSP only detects the 
trigger when it's value is exceeded, the system will for an instant 
actually run faster.

The second frame updates the acceleration with zero, causing the 
system to stop accelerating.  The velocity is then forced to the 
desired velocity.  Since there is no FTRG_... value specified in the 
Trigger/Update mask, this frame will execute until either the PC or 
an input sensor triggers another action.

If negative-direction motion is required, use the following code:

int negative_vel(int axis, double vel, double accel)
{	int e;
	FRAME frame;

	if (accel > 0)
		accel = -accel;
	if (vel > 0)
		vel = -vel ;

	e = frame_m(&frame, "0l av un d",
			axis, accel, vel, FUPD_ACCEL | FTRG_VELOCITY, 
	TRIGGER_NEGATIVE | NEW_FRAME);
	if (!e)
		e = frame_m(&frame, "0l av u d",
			axis, (double) 0.0, vel, FUPD_ACCEL|FUPD_VELOCITY);
	if (!e)
		e = pcdsp_set_pc_event(&dsp, axis, NEW_FRAME);
	return e;
}

There are two differences between a negative move and a positive one: 
The acceleration and velocity figures' signs indicate the direction 
of motion, and the Trigger Action's negative trigger bit must be on. 
Without the negative trigger bit, the final velocity being much less 
than the current velocity will cause the DSP to immediately trigger. 
Note that since the second (constant velocity) frame has no trigger, 
TRIGGER_NEGATIVE isn't required.



2)  An n-second dwell or an I/O output change before a trapezoidal 
profile move.  start_move(...) simply calculates the frames required 
for a trapezoidal profile move.  By inserting a frame before 
start_move(...), we can have a delay or I/O state change.

dwell_frame(...) simply loads a time-triggered frame into the PC-DSP 
card.  The seconds parameter can be any value from 1/sample_rate 
through 2__/sample_rate seconds.  The timer has a maximum resolution 
of 1/sample_rate.

int dwell_frame(int axis, double seconds)
{	FRAME frame ;
	return frame_m(&frame, "0 l t u d", axis, seconds, FTRG_TIME);
}


io_frame(...) will adjust an output port.  User I/O ports 0..3 start 
at the address USER_IO, and 4..6 start at AUX_USER_IO.  Don't forget 
to call init_io before trying to update output bits.  This routine 
relies on the fact that this frame isn't using the Jerk field for any 
other purpose:

int io_frame(int axis, unsigned port, unsigned value)
{	FRAME frame;
	if (port < 4)
		port += USER_IO;
	else
		port += AUX_USER_IO ;
	return frame_m(&frame, "0 l O u d", axis, OUTPUT_JERK, port, 
value, value, FUPD_OUTPUT);
}


Now, to use these functions, simply call them in front of 
start_move(...).  your_delaying_function will return before any 
motion starts.  1/2 second later, the motion will begin.

void your_delaying_function(...)
{
	if (! dwell_frame(axis, .5))
		start_move(axis, finalPos, vel, accel);
}


In your_outputting_function(...), port A of the User I/O port will be 
set to 0x55, the board will wait 1/4 of a second, and then motion 
will begin.

# include "idsp.h"
void your_outputting_function(...)
{
	if (	!io_frame(axis, 0, 0x55) &&
		!dwell_frame(axis, .25))
		start_move(axis, finalPos, vel, accel);
}


Complex combinations of these two functions can be used to turn on 
output bits, wait a period of time, and move.  We can also call these 
routines after the end of start_move to tell the controller to 
automatically adjust I/O after the motion is done:


int foo(int axis, double posn, double vel, double accel)
{	if ((start_move(axis, posn, vel, accel) == DSP_OK) &&
		(dwell_frame(axis, .25) == DSP_OK))
		return io_frame(axis, 0, 0x00);
	return dsp_error ;
}

The controller will perform the trapezoidal profile motion, wait 1/4 
second, and turn off all the outputs of user I/O port 0.

Here is a function which turns on an output bit, performs a 
trapezoidal profile move, and turns the bit off after its finished.

int bmove(int axis)
{	FRAME	frame ;

	frame_m(&frame, "0l O u d", axis, OUTPUT_JERK, USER_IO, 0x01, 
0xFF, FUPD_OUTPUT);
	start_move(axis, FINAL, VEL, ACCEL);
	frame_m(&frame, "0l O u d", axis, OUTPUT_JERK, USER_IO, 0x00, 
0xFE, FUPD_OUTPUT);

	return dsp_error ;
}
